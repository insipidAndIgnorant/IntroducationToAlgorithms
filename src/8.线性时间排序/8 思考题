8.1
  a: 设有x个叶节点标有1/n! 如果x != n!
  则概率之和不为1

  b:
  D(LT) = D(T)/2 - k/2
  D(RT) = D(T)/2 - k/2
  D(T) = D(LT) + D(RT) + k

  // 精准证明参考8.1-b.png

  c:
  d:
  e:

8.2
a: 
  遍历数组 用两个额外数组记录结果
  每次将0或1翻入对应数组
  最后合并数组 O(3n)

b:
  遍历数组
  将0与第一个1交换， 1跳过（即连在1后面）

c:
  将b的交换改为向前移动（与插入排序类似）

d:
  不可以要abc均满足的才能
e:
function countingSort1 (A, k) {
    let C = [];
    for (let i = 0; i <= k; i++) {
        C[i] = 0;
    }
    for (let i = 0; i < A.length; i++) {
        C[A[i]] += 1;
    }
    for (let i = 1; i <= k; i++) {
        C[i] += C[i -1];
    }
    let p = 0;
    for (let i = 0; i <= C.length; i++) {
        
        if (C[i] === 0 || C[i] === C[i - 1]) {
            continue
        } else {
			      let len = C[i-1] ? C[i] - C[i-1] : C[i]
            for (let j = 0; j < len; j++) {
                A[p] = i
                p++
            }
        }
    }

    return A
}

8.3
a:
  先用计数排序按每个数位数排序
  再用计数排序对每个位数相同的部分进行排序
b:
  .首先按首字母排序，然后对于首字母相同的一组，统计其长度；比较第二个字母时，长度为1的字符串不在考虑之列，比较第三个字母时，长度为1,2的字符串不在考虑之列。。。。

  递归过程：
  1.根据首字母分组并按首字母排序，得到首字母为x的数组A[s,e]
  2.根据第二个字母分组并排序，其中只有一个字母的序列不在考虑之列，可以得到 A[s1..e1],A[s2..e2],A[s3..e3]。。。
  3.对于第二个字母相同的如A[s1..e1]，根据第三个字母排序并分组，只有两个字母的序列不在考虑之列，可以得到A[s11..e11],A[s12..e12]。。。。
  4.重复过程，直至得到的分组为空

8.4
 a:
 循环内套循环
 b:
 c:
 1.从红色水壶中随机选择一个水壶作为主元。
 2.从蓝色水壶中找到与红水壶主元容量一样的水壶。
 3.完成蓝色水壶组的划分操作。(比红水壶主元容量大的在右，比A主元容量小的在左)
 4.重复上面123来对红水壶组进行相同的三步操作，来完成一次PARTITION函数划分红水壶组与蓝水壶组操作。
 5.对划分后的红蓝水壶组做递归，不断重复上述4步骤，然后同时完成对红与蓝水壶的排序操作，这样按顺序红蓝水壶一样容量的一一对应完成配对

8.5:
a:
  完全排序
b:
  1,3,2,4,6,5,7,9,8,10
c:
  两边∑式展开后，左右两边个剩一项 也就是最终结论：A[i]≤A[i+k] 
d:
  这里要求的是k排序，就是只有A[i],A[i+k],A[i+2k]....的升序关系，
  另一组只要有A[j].A[j+k],A[j+2k]....的升序关系即可，
  这样的话把数组划分成k组，每组n/k个元素，然后对每一组进行快速排序，总的代价为：theta(nlg(n/k))；
  然后依次读出第一组的第一个元素，第二组的第一个元素....第k组的第一个元素；第一组的下一个元素，第二组的下一个元素....即可；
e:
  6.5.9利用堆
f:
  可以用决策树模型。
  可以看成对于n个数分成k组数，分别对每组n/k个数进行排序，所用方法是决策树，这n/k个数有(n/k)!种排列，其下界为Ω((n/k)lg(n/k)),
  那么对于k组数非严格证明就是把这k组数下界相加，那么就有Ω(k(n/k)lg(n/k))=Ω(nlg(n/k))
  因为k是常数，对于足够大的n 常数k忽略不计，所以有Ω(nlg(n/k))=Ω(nlg(n))

8.6
a:
  C(2n, n)
b:
c:
d:

8.7
 a:
 