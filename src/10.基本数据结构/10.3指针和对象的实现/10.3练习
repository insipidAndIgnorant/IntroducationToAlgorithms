10.3-1
  2     3    4    5     6    /
  13    4    8    19    5    11
  /     1    2    3     4    5

  2     3    4    5     6    /
  13    4    8    19    5    11

10.3-2
  ALLOCATE-OBJECT:
    x= free
    free = x->+2
  FREE-OBJECT
    x->+1 = free
    free = x

10.3-3
  自由表只使用next,类似于栈只需要顶层， 不需要pre

10.3-4
  将自由表用栈存储？？？

  设置一个栈指针，该指针总是指向栈顶元素。 假设当前数组中前m个位置保存了m个对象。此时栈指针指向m。 删除对象的时候，设待删除对象的位置为x，
  交换位置x与栈指针位置的对象，然后删除栈顶元素。 插入的时候，栈顶位置加1，然后插入对象。 也就是说，插入和删除总是对栈顶元素操作。所以类似于一个栈。

10.3-5
  a:
  从链表头和自由表头同时扫描 ，交换“易位”元素 O(max(n,m-n))
  b:
  扫描链表，将不在链表区的交换到自由表尾部
  顺序扫描数组前n位，将自由表元素与 自由表尾部脸部元素交换O(2n)


  // 毛子大神解法
  （1）我们遍历F并通过在其prev字段中放置一个特殊值来标记每个元素；
  （2）我们启动两个指针，一个从内存开始处开始，一个从结尾开始。我们递增左指针直到它到达一个空单元格并递减右指针直到它到达非空单元格。我们将右指针指向的元素移动到左指针指向的位置，并在next字段中保留转发地址。当两个指针相遇时终止。此时，L位于数组的开头，而F位于最后。记录这个分界。
  （3）我们通过使用next转发地址线性扫描数组的第一部分并更新超出分界的所有指针。
  （4）最后，我们在自由列表中组织超出阈值的内存。